# 회고록(김재원)

# 메인프로젝트 회고

이번 메인 프로젝트(야픽 - 푸드트럭 이용 서비스)에서 저는 푸드트럭의 CRUD와 푸드트럭 정보와 음식 메뉴의 CRUD를 맡았습니다.

저번 프리 프로젝트때 사용했던 기술스택으로

- **module.css**
- **axios**
- **React hooks**

를 사용 하였고 이번 메인 프로젝트에서는 제가 처음 접해보는 기술스택들을 도전해보기로 하였습니다.

저번 프리때의 단점을 보완하고자 **Module.css**에서 **Styled-Component**로 통신쪽은 **Axios와 React Query**로 상태관리는 **Recoil**을 사용해 보았습니다.

이와같은 기술스택들을 처음으로 짧은 시간 접하게 되면서 저는 저번 프리 프로젝트때보다 개선된점을 발견할 수 있었습니다.

### Styled-Component

css에서 Module.css로 넘어갔을땐 일일히 class와 id를 붙여 중복을 피해 네이밍해야 하던때와 달리 className에 `styles.클래스 이름`으로 사용해 css를 컴포넌트처럼 스타일링이 필요한 태그마다 여러개를 적용할 수 있어 좋았습니다.

Styled-Component는 module.css처럼 네이밍에 있어서 문제가 없고 재사용또한 자유로워 매우 효율적이였습니다. 거기에 `js 환경에서 스타일링` 하기에 **props** 전달로 유동적이게 일부 스타일링도 엘리먼트마다 변경이 가능했습니다. `styled.태그명` 으로 사용하여 js에서 구현 가능한 조건부 스타일링또한 가능하며, 볼륨이 크지 않은경우 하나의 js 파일에서 스타일링까지 모두 작성이 가능해 쓰는 내내 여러 기술들에 놀랐습니다.

### React Query

러닝 커브가 있어 걱정했던 기술이였는데 팀장님의 도움으로 레퍼런스와 조언을 통해 몆가지 중요한 기능들을 사용할 수 있었습니다. 제가 주로 사용했던 기능들은

- **useQuery**
- **useMutate**

이며 CRUD기능을 위해 백엔드분들과 통신을 뚫을때 사용하였습니다. axios도 사용했지만, axios만 사용했을때와는 달리 정말 천차만별인 기능들이 있었고 그 중 `캐싱` 부분과 `자동 Update` 그리고 `분기처리` 이 인상 깊었습니다.

**캐싱**부분은 session storage에 장바구니에 메뉴 리스트 배열을 넣어 백엔드 분들에게 session storage를 통해 넘겨드렸고, 기본적으로 get으로 가져온 정보를 로컬에 저장해두어 다시 왔을때 재통신이 이루어 질 필요없이 로컬에 저장된 값을 유저에게 줌으로 가독성을 높일 수 있었습니다.

**queryClient.invalidateQueries()** 이 기능또한 정말 편리하게 사용하였습니다. 저번 프리프로젝트때 update되면 강제로 렌더링 시키기위해 window 새로고침을 주었고 팀장님께 혼났습니다. 이 기능은 간편하게 update 되어야 하는 get 함수를 (`여기`) 안에 넣어 post통신이 성공했을때 이 코드를 넣어 실행시킵니다. 그럼 mutation 함수가 성공하면 해당 get 함수도 자동 재실행 됩니다!

**분기처리**는 프리프로젝트때 useState로 IsLoading, IsError, IsSuccess로 분기처리 하였으며 일일히 로딩과 에러 성공 로직을 짜서 구현하였습니다. 리액트 쿼리는 통신기능안에 미리 옵션기능으로 **OnSuccess**, **OnError** 의 분기처리 기능과, retry, refetchOnwidowfoucs등 통신 실패시 다시 재통신 시도하는 횟수, 재실행까지의 텀, 다른탭, 윈도우로 나가고 다시 왔을때의 재통신 등등 다양한 옵션들이 있었고 변수로 꺼내 사용할 수 있는 **isLoading**, **isError**, **data** 등으로 로딩일때, 로딩 화면의 컴포넌트를 출력하게 해주며 에러일때와 통신을 통해 가져온 **data**를 자유롭게 사용할 수 있었습니다.

### Recoil

useState에서 쓰다가 넘어온 저에게 리코일은 너무나 편했습니다. 첫번째로 가는곳마다 useState를 만들어줄 필요 없이 store에 atoms 를 원할때 가져다 사용해 효율적이였습니다. 두번째로 전역으로 상태관리가 가능하다는 점 입니다. 다른 페이지에서 구독하여 변화가 있으면 해당 atom을 구독한 모든 컴포넌트가 재 렌더링되어 전역으로 상태관리를 쉽고 효율적이게 관리할 수 있었습니다.

### withAuth

가게설정 페이지를 useparams로 회원 id값을 받아와 데이터를 뿌려주고 수정, 삭제 기능을 구현 하고 있었습니다. 그러던와중 생각난게 만약 유저가 악의적으로 url의 파라미터 부분만 바꿔 다른 유저의 정보를 관람, 삭제, 수정할 수 있겠다는 문제점을 발견해 멘토님과 상의하여 withAuth 기능을 사용해 보기로 하였습니다. 완벽히 이해하여 사용하기까지 시간적으로 여유가 없어 원리만 빠르게 이해하고 기능을 구현하는데 성공했습니다. UX를 보다 높이기 위해 이런 보안쪽도 항시 생각해둬야 한다고 느꼈습니다.
